import { S as SvelteComponent, i as init, s as safe_not_equal, c as create_slot, e as element, d as text, f as space, h as claim_element, j as children, k as claim_text, l as detach, m as insert, o as append, B as set_data, g as get_slot_changes, a as get_slot_context, t as transition_in, b as transition_out, C as subscribe } from './chunk.d4046557.js';
import { b as stores$1 } from './chunk.e787e967.js';
import { c as counts } from './chunk.4b200f2f.js';

/* test/apps/layout/src/routes/[x]/[y]/_layout.svelte generated by Svelte v3.6.9 */

function create_fragment(ctx) {
	var span0, t0, t1_value = ctx.$page.params.y, t1, t2, t3, t4, t5, span1, t6, t7, current;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			span0 = element("span");
			t0 = text("y: ");
			t1 = text(t1_value);
			t2 = space();
			t3 = text(ctx.count);
			t4 = space();

			if (default_slot) default_slot.c();
			t5 = space();
			span1 = element("span");
			t6 = text("child segment: ");
			t7 = text(ctx.segment);
		},

		l(nodes) {
			span0 = claim_element(nodes, "SPAN", {}, false);
			var span0_nodes = children(span0);

			t0 = claim_text(span0_nodes, "y: ");
			t1 = claim_text(span0_nodes, t1_value);
			t2 = claim_text(span0_nodes, " ");
			t3 = claim_text(span0_nodes, ctx.count);
			span0_nodes.forEach(detach);
			t4 = claim_text(nodes, "\n");

			if (default_slot) default_slot.l(nodes);
			t5 = claim_text(nodes, "\n\n");

			span1 = claim_element(nodes, "SPAN", {}, false);
			var span1_nodes = children(span1);

			t6 = claim_text(span1_nodes, "child segment: ");
			t7 = claim_text(span1_nodes, ctx.segment);
			span1_nodes.forEach(detach);
		},

		m(target, anchor) {
			insert(target, span0, anchor);
			append(span0, t0);
			append(span0, t1);
			append(span0, t2);
			append(span0, t3);
			insert(target, t4, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t5, anchor);
			insert(target, span1, anchor);
			append(span1, t6);
			append(span1, t7);
			current = true;
		},

		p(changed, ctx) {
			if ((!current || changed.$page) && t1_value !== (t1_value = ctx.$page.params.y)) {
				set_data(t1, t1_value);
			}

			if (!current || changed.count) {
				set_data(t3, ctx.count);
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}

			if (!current || changed.segment) {
				set_data(t7, ctx.segment);
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(span0);
				detach(t4);
			}

			if (default_slot) default_slot.d(detaching);

			if (detaching) {
				detach(t5);
				detach(span1);
			}
		}
	};
}

function preload() {
	return {
		count: counts.y += 1
	};
}

function instance($$self, $$props, $$invalidate) {
	let $page;

	const { page } = stores$1(); subscribe($$self, page, $$value => { $page = $$value; $$invalidate('$page', $page); });

	let { count, segment } = $$props;

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('count' in $$props) $$invalidate('count', count = $$props.count);
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		page,
		count,
		segment,
		$page,
		$$slots,
		$$scope
	};
}

class Layout extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, ["count", "segment"]);
	}
}

export default Layout;
export { preload };
