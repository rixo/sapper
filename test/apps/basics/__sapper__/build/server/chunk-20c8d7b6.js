'use strict';

var __chunk_1 = require('./chunk-ca2ab714.js');

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = __chunk_1.noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (__chunk_1.safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = __chunk_1.noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || __chunk_1.noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

const CONTEXT_KEY = {};

const preload = () => ({});

/* test/apps/basics/src/node_modules/@sapper/internal/layout.svelte generated by Svelte v3.6.9 */

const Layout = __chunk_1.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `${$$slots.default ? $$slots.default() : ``}`;
});

/* test/apps/basics/src/routes/_error.svelte generated by Svelte v3.6.9 */

const Error$1 = __chunk_1.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	return `<h1>${__chunk_1.escape(status)}</h1>

	<p>${__chunk_1.escape(error.message)}</p>`;
});

/* test/apps/basics/src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.6.9 */

const App = __chunk_1.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	

	let { stores, error, status, segments, level0, level1 = null, notify } = $$props;

	__chunk_1.afterUpdate(notify);
	__chunk_1.setContext(CONTEXT_KEY, stores);

	if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0) $$bindings.stores(stores);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);
	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.segments === void 0 && $$bindings.segments && segments !== void 0) $$bindings.segments(segments);
	if ($$props.level0 === void 0 && $$bindings.level0 && level0 !== void 0) $$bindings.level0(level0);
	if ($$props.level1 === void 0 && $$bindings.level1 && level1 !== void 0) $$bindings.level1(level1);
	if ($$props.notify === void 0 && $$bindings.notify && notify !== void 0) $$bindings.notify(notify);

	return `


	${__chunk_1.validate_component(Layout, 'Layout').$$render($$result, Object.assign({ segment: segments[0] }, level0.props), {}, {
		default: () => `
		${ error ? `${__chunk_1.validate_component(Error$1, 'Error').$$render($$result, { error: error, status: status }, {}, {})}` : `${__chunk_1.validate_component(((level1.component) || __chunk_1.missing_component), 'svelte:component').$$render($$result, Object.assign(level1.props), {}, {})}` }
	`
	})}`;
});

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/delete-test\/([^\/]+?)\.json$/, /^\/ambiguous\/([^\/]+?)\.json$/, /^\/b\.json$/, /^\/(.+)\/deep\.json$/];

const components = [
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-4144bbf3.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./unsafe-replacement-1cd3b231.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:unsafe-replacement.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-e0d1283c.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:delete-test/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-c9f12b0b.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:echo-query/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-caa025e9.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:middleware/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-09ba8502.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:ambiguous/[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[two]-fc10a67f.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:skipped/[one]/[two].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[id([0-9]+)]-30a6158c.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:regexp/[id([0-9]+)].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./const-4a34ab1c.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:const.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-fca5e285.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:store/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./result-5837e7d0.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:store/result.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-eadf92e8.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:dirs/bar/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[a]-1ec62628.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:dirs/bar/[a].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-363c2569.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:dirs/foo/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[b]-f94d1d55.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:dirs/foo/[b].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./host-745326f6.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:host.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./a-c624f2de.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:a.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-15acb412.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:b/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[id([0-9]+)]-63d1d2e9.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:[id([0-9]+)].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-e2f8ce4d.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./deep-56431047.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:[...rest]/deep.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-c51b6d0d.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:[...rest]/index.svelte__"
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// unsafe-replacement.svelte
		pattern: /^\/unsafe-replacement\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// delete-test/index.svelte
		pattern: /^\/delete-test\/?$/,
		parts: [
			{ i: 2 }
		]
	},

	{
		// echo-query/index.svelte
		pattern: /^\/echo-query\/?$/,
		parts: [
			{ i: 3 }
		]
	},

	{
		// middleware/index.svelte
		pattern: /^\/middleware\/?$/,
		parts: [
			{ i: 4 }
		]
	},

	{
		// ambiguous/[slug].svelte
		pattern: /^\/ambiguous\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 5, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// skipped/[one]/[two].svelte
		pattern: /^\/skipped\/([^\/]+?)\/([^\/]+?)\/?$/,
		parts: [
			null,
			null,
			{ i: 6, params: match => ({ one: d(match[1]), two: d(match[2]) }) }
		]
	},

	{
		// regexp/[id([0-9]+)].svelte
		pattern: /^\/regexp\/([0-9]+)\/?$/,
		parts: [
			null,
			{ i: 7, params: match => ({ id: d(match[1]) }) }
		]
	},

	{
		// const.svelte
		pattern: /^\/const\/?$/,
		parts: [
			{ i: 8 }
		]
	},

	{
		// store/index.svelte
		pattern: /^\/store\/?$/,
		parts: [
			{ i: 9 }
		]
	},

	{
		// store/result.svelte
		pattern: /^\/store\/result\/?$/,
		parts: [
			null,
			{ i: 10 }
		]
	},

	{
		// dirs/bar/index.svelte
		pattern: /^\/dirs\/bar\/?$/,
		parts: [
			null,
			{ i: 11 }
		]
	},

	{
		// dirs/bar/[a].svelte
		pattern: /^\/dirs\/bar\/([^\/]+?)\/?$/,
		parts: [
			null,
			null,
			{ i: 12, params: match => ({ a: d(match[1]) }) }
		]
	},

	{
		// dirs/foo/index.svelte
		pattern: /^\/dirs\/foo\/?$/,
		parts: [
			null,
			{ i: 13 }
		]
	},

	{
		// dirs/foo/[b].svelte
		pattern: /^\/dirs\/foo\/([^\/]+?)\/?$/,
		parts: [
			null,
			null,
			{ i: 14, params: match => ({ b: d(match[1]) }) }
		]
	},

	{
		// host.svelte
		pattern: /^\/host\/?$/,
		parts: [
			{ i: 15 }
		]
	},

	{
		// a.svelte
		pattern: /^\/a\/?$/,
		parts: [
			{ i: 16 }
		]
	},

	{
		// b/index.svelte
		pattern: /^\/b\/?$/,
		parts: [
			{ i: 17 }
		]
	},

	{
		// [id([0-9]+)].svelte
		pattern: /^\/([0-9]+)\/?$/,
		parts: [
			{ i: 18, params: match => ({ id: d(match[1]) }) }
		]
	},

	{
		// [slug].svelte
		pattern: /^\/([^\/]+?)\/?$/,
		parts: [
			{ i: 19, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// [...rest]/deep.svelte
		pattern: /^\/(.+)\/deep\/?$/,
		parts: [
			null,
			{ i: 20, params: match => ({ rest: d(match[1]).split('/') }) }
		]
	},

	{
		// [...rest]/index.svelte
		pattern: /^\/(.+)\/?$/,
		parts: [
			{ i: 21, params: match => ({ rest: d(match[1]).split('/') }) }
		]
	}
])(decodeURIComponent);

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

/** Callback to inform of a value updates. */



















function page_store(value) {
	const store = writable(value);
	let ready = true;

	function notify() {
		ready = true;
		store.update(val => val);
	}

	function set(new_value) {
		ready = false;
		store.set(new_value);
	}

	function subscribe(run) {
		let old_value;
		return store.subscribe((value) => {
			if (old_value === undefined || (ready && value !== old_value)) {
				run(old_value = value);
			}
		});
	}

	return { notify, set, subscribe };
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: page_store({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;

let target;

let uid = 1;

let cid;

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top + scrollY
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};
		props.notify = stores.page.notify;

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

const stores$1 = () => __chunk_1.getContext(CONTEXT_KEY);

exports.App = App;
exports.error = Error$1;
exports.root = Layout;
exports.stores$1 = stores$1;
exports.writable = writable;
